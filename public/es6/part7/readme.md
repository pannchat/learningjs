# 스코프
스코프는 변수와 상수, 매개변수가 언제 어디서 정의되는지 결정한다. 함수 매개변수가 함수 바디 안에서만 존재하는 것도 스코프의 한 예이다.

```javascript
function f(x){
    return x + 3;
}

console.log(f(5)); //8
console.log(x); //ReferenceError: x is not defined
```

x가 아주 잠시나마 존재했었으니  x + 3 을 계산할 수 있었다. 하지만 함수 바디를 벗어나면 x는 존재하지 않는 것처럼 보인다. 따라서 우리는 x의 스코프가 함수  f 라고 말한다.
변수의 스코프가 어떤 함수라고 말할 때는, 함수를 실제 호출할 때까지는, 함수 바디의 정해진 매개변수가 존재하지 않음을 반드시 상기해야한다. 함수는 여러번 호출할 수 있따. 그리고 함수를 호출할 때마다 매개변수가 나타나고, 함수가 제어권을 반환하면 스코프 밖으로 사라진다.

변수와 상수는 만들기전에는 존재하지 않는다는 것도 확실하다. 즉  let 이나  const 로 선언하기 전에는 스코프 안에 존재하지 않는다. 

> 일부 언어는 선언 (declaration)과 정의 (definition)을 명확히 구분한다. 일반적으로 변수를 선언한다는 것은 식별자를 주어서 그 존재를 알리는것. 반면 정의는 선언과 함께 값도 부여하는 것을 말한다. 자바스크립트에서는 모든 변수를 선언하는 동시에 값이 주어지므로( 명시적으로 정하지 않으면 undefined가 암시적으로 주어지므로) 두 용어를 구분하지 않는다.
# 스코프와 존재
변수가 존재하지 않으면 그 변수는 스코프 안에 ‘있지 않음’ 을 직관적으로 알 수 있다 즉, 아직 선언하지 않은 변수나 함수가 종료되면서 존재하지 않게 된 변수는 분명 스코프 안에 ‘있지 않다’

변수가 스코프 안에 있지 않다면, 그 변수는 존재하지 않는다는 말은 아니다. 그리고 여기서 스코프와 존재를 반드시 구별해야 한다.

가시성 visibility 라고도 불리는 스코프는 프로그램의 현재 실행 중인 부분 즉 , 실행 컨텍스트 execution context 에 현재 보이고 접근할 수 있는 식별자들을 말한다. 반면 존재한다는 말은 그 식별자가 메모리가 할당된(예약된) 무언가를 가리키고 있다는 뜻이다.

# 정적스코프와 동적스코프
자바스크립트의 스코프는 정적이다. 소스코드만 봐도 변수가 스코프에 있는지 판단할수있다. 다만 소스코드만 봐도 즉시 스코프를 분명히 알 수 있다는 뜻은 아니다.

# 정적스코프
어떤 변수가 함수 스코프 안에 있는지 함수를 정의할 때 알 수 있다는 뜻이다.
호출할 때 알 수 있는 것은 아니다. 자신이 정의 될 때 접근 할 수있었던 식별자에는 여전히 접근할 수 있지만, 호출 할 때 스코프에 있는 식별자는 접근 할 수 없다.

# 전역스코프
전역스코프에서 선언한 것은 무엇이든 프로그램의 모든 스코프에서 볼 수있다.
전역스코프에서 선언된 것들을 전역변수(global) 이라고 한다.
전역스코프에 의존하는 것은 피해야한다.

# 블록스코프
let 과 const 는 식별자를 블록스코프에서 선언한다.
블록스코프는 블록(문을 중괄호로 묶은것)의 스코프에서만 보이는 식별자를 의미한다.

# 변수 숨기기
```javascript
{
// 외부블록
let x = ‘blue’
console.log(x); // blue
{
	//내부블록
	let x = 3;
	console.log(x); // 3
}
console.log(x); // blue
}
console.log(typeof x); // "undefined"; x는 스코프에 있지 않습니다.

```

내부블럭의 x는 외부 블록에서 정의한 x와 이름만 같을 뿐 다른 변수이므로 외부 스코프의 x를 숨기는 효과가 있다.
실행 흐름이 내부 블록에 들어가 새 변수 x를 정의 하는 순간 두 변수는 모두 스코프안에 있다.( 외부 변수가 숨겨짐)
변수의 이름이 같으므로 외부 스코프에 있는 변수에 접근할 방법이없다.

# 스코프 체인
스코프가 계속 연결됨(중첩),. 스코프안에 스코프가 있는 형태
내부 함수에서는 외부 함수의 변수에 접근이 가능하지만 외부 함수에서는 내부 함수의 변수에 접근 할 수 없다.
모든 함수들은 전역 객체에 접근할 수 있다.

# 함수, 클로저, 정적스코프
클로저는 함수가 특정 스코프에 접근 할 수 있도록 의도적으로 그 스코프에서 정의하는 경우, 스코프를 함수 주변으로 좁히는것을 말한다.

```javascript
let globalFunc; //정의 되지 않는 전역 함수
{
	let blockVar = “a”; //블록 스코프에 있는 변수 
	globalFunc = function(){
		console.log(blockVar);
	}
}
globalFunc(); // “a”
```

globalFunc는 블록 안에서 값을 할당 받았다. 이 블록 스크로와 그 부모인 전역 스코프가 클로저를 형성한다. globalFunc를 어디서 호출하든 이 함수는 클로저에 들어있는 식별자에 접근할 수 있다. globalFunc를 호출하면, 이 함수는 스코프에서 빠져나왔음에도 불구하고 BlockVar에 접근할 수 있다.
일반적으로 스코프에서 빠져나가면 해당 스코프에서 선언한 변수는 메모리에서 제거해도 안전하다. 하지만 여기서는 스코프 안에서 함수를 정의했고, 해당함수는 스코프 밖에서도 참조할 수 있으므로 자바스크립트는 스코프를 계속 유지한다.

즉, 스코프안에서 함수를 정의하면 해당 스코프는 더 오래 유지된다. 또한 일반적으로는 접근할수 없는것에 접근할수 있는 효과도 있다.

```javascript
let f; //정의되지 않은 함수
{
    let o = {note : ‘Safe’};
    f = function(){
        return o;
    }
}
console.log(f());

let oRef = f();
oRef.note = ‘Not so safe after all!’;

console.log(oRef);

```

```결과
{ note: 'Safe' }
{ note: 'Not so safe after all!' }
```

일반적으로는 자신의 스코프에 없는 것들에는 접근할 수 없다. 함수를 정의해 클로저를 만들면 접근할 수 없던것들에 접근할 방법이 생기고 이건 매우 중요한 측면이다.

# 즉시 호출하는 함수 표현식
함수표현식을 사용하면 즉시 호출하는 함수 표현식(IIFE)란 것을 만들 수 있다. IIFE는 함수를 선언하고 즉시 실행한다.  IIFE는 다음과 같은 형태를 취한다.
```javascript
(function(){
	// IIFE 바디
})();
```

함수표현식으로 익명함수를 만들고 그 함수를 즉시 호출함. IIFE의 장점은 내부에 있는 것들이 모두 자신만의 스코프를 가지지만, IIFE자체는 함수이므로 그 스코프 밖으로 무언가를 내보낼 수 있다.

```javascript
const message = (function(){
    const secret = “I’m a secret!”;
    return `The secret is ${secret.length} characters long`;

})();
console.log(message);
```

변수 secret 은 IIFE의 스코프안에서 안전하게 보호되며 외부에서 접근할 수 없다. IIFE는 함수이므로 무엇이든 반환할 수 있다. IIFE에서 배열이나 객체, 함수를 반환하는 경우도 무척 많다. 자신이 몇 번 호출됐는지 보고하는 함수를 생각해 보면 이함수가 몇번 호출됐는지 저장한 값을 외부에서는 절대 손댈 수 없다.

```javascript
const f = (function(){
    let count = 0;
    return function(){
        return `I have been called ${++count} time(s)`;
    }
})();
console.log(f()); 
console.log(f());
console.log(f());
console.log(f());
console.log(f());
// I have been called 1 time(s)
// I have been called 2 time(s)
// I have been called 3 time(s)
// I have been called 4 time(s)
// I have been called 5 time(s)

```

변수 count는 IIFE안에 안전하게 보관되어 있으므로 손댈 방법이 없다. f는 자신이 몇번호출 되었는지 정확히 알고 있다.
ES6에서 블록 스코프 변수를 도입하면서 IIFE가 필요한 경우가 줄어들긴 했지만 여전히  널리 쓰인다. 클로저를 만들고 클로저에서 무언가 반환받을 때에는 유용하게 쓸 수 있다.

# 함수 스코프와 호이스팅
ES6에서 let을 도입하기 전에는 var을 써서 변수를 선언했고, 이렇게 선언된 변수들은 함수 스코프라 불리는 스코프를 가졌다(VAR로 선언한 전역변수는 명시적인 함수 안에 있지는 않지만 함수 스코프와 똑같이 동작한다)
let으로 변수를 선언하면, 그 변수는 선언하기 전에는 존재하지 않는다. Var로 선언한 변수는 현재 스코프 안이라면 어디서든 사용할 수 있으며, 심지어 선언하기도 전에 사용할 수 있다. 예제를 보기전에 아직 선언되지 않은 변수와 값이 undefined인 변수는 다르다는 점을 상기하자. 아직 선언되지 않은 변수는 에러를 일으키지만, 존재하되 값이 undefined인 변수는 에러를 일으키지 않는다
```javascript
let var1;
let var2= undefined;
console.log(var1); // undefined
console.log(var2); // undefined
console.log(undefinedVar); // ReferenceError: undefinedVar is not defined
```

let을 쓰면 변수를 선언하기 전 사용하려할 때 에러가 난다.

```javascript
x; //ReferenceError: x is not defined
let x = 3;
x; // 3
```

반면 var로 변수를 선언하면 선언하기전에 사용할 수 있다.
```javascript

console.log(x);
var x =3 ;
console.log(x);

```

var로 선언한 변수는 끌어올린다는 뜻의 호이스팅 hoisting이라는 매커니즘을 따른다. 자바스크립트는 함수나 전역 스코프 전체를 살펴보고  var로 선언한 변수를 맨 위로 끌어올린다. 여기서 중요한것은 선언만 끌어올려진다는 것이며, 할당은 끌어올려지지 않는다는 것이다. 자바스크립트는 이전예제를 다음과 같이 해석한다.
```javascript
var x; // 선언(할당은 아닌) 이 끌어올려진다.
console.log(x); // undefined
x =3; 
console.log(x) //3
```

```javascript
// 원래 코드

if( x !== 3){
console.log(y);
	var y = 5;
	if( y === 5 ){
		var x = 3;
	}
console.log(y);
}
if( x === 3){
	console.log(y);
}
``` 

```javascript
// 자바스크립트가 해석한 코드
var x ;
var y ; 
if( x ! == 3 ) {
	console.log(y);
	y = 5;
	if( y === 5){
		x = 3;
	}
	console.log( y );
	}
}
if ( x === 3) {
	console.log( y );
}
```

원래 코드가 모범적인 코드라는것이 아니다. 변수를 선언하기도 전에 사용하면 불필요하게 혼란스럽고, 에러에도 취약하다. 이렇게 해야 할 현실적인 이유가 있는 것도 아니다. 이 코드를 제시한 이유는 호이스팅이 어떻게 동작하는지 잘 보여주기 때문인다. var을 이용해 변수를 선언 하면 자바스크립트는 같은 변수를 여러 번 정의하더라도 무시한다.

이런스타일이 권장되는것이 아니다. 이런 스타일은 혼랑늘 초래할 뿐이다.  대부분의 독자, 특히 다른언어에 익숙한 독자들은 이 예제를 힐끗 보고 필자가 if 문의 블록 스코프 안에 새 변수 x를 만들려한다고 생각할수 잇지만 ,그런일은 일어나지 않았다.

> var을 쓰면 혼란스럽고 쓸모 없는 코드가 생길 수 있는데 왜이런 키워드를 만들었는지 의문이 든다면 let 키워드가 만들어진 이유를 이해한거다. 물론 var을 써도 명확하고 이해하기 쉬운코드를 작성할 수 있지만, 혼란스럽고 불명확한 코드를 작성할 위험은 여전하다. var을 뜻어 고치면 기존 코드가 모두 망가지므로 대신 ES6에서 let을 새로 만든것이다.

> 이 책의 저자는 let 대신 var 를 써서 더 좋은 코드나 더 명확한 코드를 쓰는 방법을 도저히 떠올릴수 없다. 다시말해 var에는 let보다 나은 점이 전혀 없다. 저자를 포함해 자바스크립트 커뮤니티 대부분 let 이 언젠가 var를 완전히 대체할 것으로 생각ㅎ나다. 언젠가는 var가 최종적으로 폐기되는 날이 올 수도 있다고 말한다.

### 그럼 왜 호이스팅을 이해해야하는가?
이유는 두 가지이다. ES6을 어디에서도 쓸수 잇으려면 아직 시간이 더필요하므로 ES5로 트랜스 컴파일을 해야한다. 기존 코드는 전부 ES5로 작성됐다. 따라서 아직은 var 가 어떻게 동작하는지 이해하고 있어야한다. 두번째이유는 함수 선언 역시 끌어올려진다. 
